# volatile與jmm

## 被volatile修飾的變量有2大特點
* 特點
  1. 可見性
  2. 有序性：有排序要求，有時需要**禁止重排**
* 內存語意
  * 當寫一個volatile變量時，JMM會把該線程對應的本地內存中的共享變量值立即刷新回主內存中
  * 當讀一個volatile變量時，JMM會把該線程對應的本地內存設置為無效，重新回到主內存中讀取最新共享變量的值
  * 所以volatile的寫內存語意是直接刷新到主內存中，讀內存語意是直接從主內存中讀取
* volatile憑什麼可以保證可見性和有序性？
  * 內存屏障Memory Barrier

## 內存屏障

### 先看volatile兩大特性
* 可見：寫完後**立即刷新回主內存並及時發出通知**，大家可以去主內存拿取最新版，前面的修改對後面所有線程可見
* 有序(禁止重排)：重排序是指編譯器和處理器為了優化程序性能而對指令序列進行重新排序的一種手段，有時候會改變程序與句的先後順序
  * 若不存在數據依賴關係，可以重排序
  * **存在數據依賴關係，禁止重排序**
  * 但重排序後的指令絕對不能改變原有的串行語意，這點在並發中必須要重點考慮

### 內存屏障是什麼
內存屏障(也稱內存柵欄，屏障指令等)是一類同步屏障指令，**是CPU或編譯器在對內存隨機訪問的操作中的一個同步點，使此點之前的所有讀寫操作都執行後才可以開始執行此點後的操作，避免代碼重排序**。
內存屏障其實就是一種JVM指令，Java內存模型的重排序會要求Java編譯器在生成JVM指令時插入特定的內存屏障指令，通過這些內存屏障指令，volatile實現了Java內存模型中的可見性和有序性(禁止重排)，但**volatile無法保證原子性**

* **內存屏障之前的所有寫操作都要回寫到主內存**
* **內存屏障之後的所有讀操作都能獲得內存屏障之前的所有寫操作的最新結果**(實現了可見性)

```text
寫屏障(Store Memory Barrier)：告訴處理器在寫屏障之前將所有存儲在緩存(store buffer)中的數據同步到主內存，也就是說當看到Store屏障指令，就必須把該指令之前的所有寫入指令執行完畢才能繼續往下執行
讀屏障(Load Memory Barrier)：處理器在讀屏障之後的讀操作，都在讀屏障之後執行。也就是說在Load屏障指令之後就能夠保證後面的讀取數據指令一定能夠讀取到最新的數據
```

因此**重排序時，不允許把內存屏障之後的指令重排序到內存屏障之前**。一句話：**對一個volatile變量的寫，先行發生於任意後續對這個volatile變量的讀**，也叫**寫後讀**。

### 內存屏障分類
* 粗分2種
  1. 寫屏障(Store Barrier)：在寫指令之後插入寫屏障，強制把寫緩衝區的數據刷回到主內存中
  2. 讀屏障(Load Barrier)：在讀指令之前插入讀屏障，讓工作內存或CPU高速緩存當中的緩存數據失效，重新回到主內存中獲取最新數據
* 細分4種
  1. LoadLoad(Load1;LoadLoad;Load2)：保證Load1的讀取操作在Load2和後續讀取操作之前執行
  2. StoreStore(Store1;StoreStore;Store2)：在Store2以及其後的寫操作執行之前，保證Store1的寫操作已經刷新到主內存
  3. LoadStore(Load1;LoadStore;Store2)：在Store2以及其後的寫操作執行前，保證Load1的讀操作已讀取結束
  4. StoreLoad(Store1;StoreLoad;Load2)：保證Store1的寫操作已經刷新到主內存之後，Load2以及其後的讀操作才能執行