# Synchronized與鎖升級


## Synchronized的性能變化

* Java5以前，只有synchronized，這是操作系統級別的重量級操作

  * 重量級鎖，假如競爭激烈的話，性能急遽下降
  * **會牽涉用戶態和內核態的切換(容易導致阻塞)**![image.png](./assets/image.png)
* Java6開始為了減少獲得鎖和釋放鎖帶來的性能消耗，引入了**輕量鎖和偏向鎖**，需要有個逐步升級的過程，別一開始到重量級鎖。

## Synchronized鎖種類和升級流程

### 升級流程

* synchronized用的鎖是存在Java對象頭裡的Mark Word中，鎖升級功能主要依賴Mark Word中鎖標誌位和釋放偏向鎖標誌位![image.png](./assets/1709091816427-image.png)
* 鎖指向
  * **偏向鎖：Mark Word存儲的是偏向的線程ID**
  * **輕量鎖：Mark Word存儲的是指向線程棧中的Lock Record的指針**
  * **重量鎖：Mark Word存儲的是指向堆中的Monitor對象的指針**

### 無鎖

初始狀態，一個對象被實例化後，如果還沒有被任何線程競爭鎖，那他就為無鎖狀態(**001**)

HashCode是由每組字節由右下往左上看的

![image.png](./assets/1709093089109-image.png)

### 偏向鎖

**單線程競爭**，當線程A第一次競爭到鎖時，通過修改Mark Word中的偏向線程ID、偏向模式。如果不存在其他線程競爭，那麼持有偏向鎖的線程將永遠不需要進行同步。

**當同一段同步代碼一直被同一個線程多次訪問，由於只有一個線程那麼該線程在後續訪問時便會自動獲得鎖。**(避免多次用戶態和內核態的切換)

*結論*：

* HotSpot的作者經過研究發現，多線程大多情況下，鎖不僅不存在多線程競爭，還存在鎖**由同一個線程多次獲得的情況**。偏向鎖就是在這種情況下出現的，他的出現是為解決**只有在一個線程執行同步時提高性能**。
* 偏向鎖會會偏向於第一個訪問鎖的線程，如果在接下來的運行過程中，該鎖沒有被其他線程訪問，則持有偏向鎖的線程將永遠不需要觸發同步。也即偏向鎖在資源沒有競爭情況下消除了同步語句，連CAS都不做了，提高程序性能。

*理論*：在實際應用運行過程中發現，"鎖總是同一個線程持有，很少發生競爭"，也就是說**鎖總是被第一個佔用他的線程持有，這個線程就是鎖的偏向線程**。那麼只需要在鎖第一次被擁有的時候，記錄下偏向線程ID。這樣偏向線程就一直持有著鎖(後續這個線程進入和退出這段加了同步鎖的代碼塊時，**不需要再次加鎖和釋放鎖**。而是直接去檢查鎖的Mark Word裡面是不是放得自己的線程ID)。如果相等表示偏向鎖事偏向於當前線程的，就不需要嘗試獲得鎖了，直到競爭發生才釋放鎖。以後每次同步，檢查鎖的偏向線程ID與當前線程ID是否一致，如果一致直接進入同步。無需每次加鎖都去CAS更新對象頭。**如果自始至終鎖的線程只有一個，很明顯偏向鎖幾乎沒有額外開銷，性能極高**。如果不等，表示發生了競爭，鎖已經不是總是偏向於同一個線程了，這個時候會嘗試使用CAS來替換Mark Word裡面的線程ID為新的線程ID。

* **競爭成功**，表示之前的線程不存在了，Mark Word裡面的線程ID為新線程的ID，鎖不會升級，仍然為偏向鎖。
* **競爭失敗**，這時候可能需要升級變為輕量級鎖，才能保證線程間公平競爭鎖。

💡**偏向鎖只有遇到其他線程嘗試競爭偏向鎖時，持有偏向鎖的線程才會釋放鎖，線程是不會主動釋放偏向鎖的**。

*技術實現*：一個synchronized方法被一個線程搶到了鎖時，那這個方法所在的對象就會在其所在的Mark Word中將偏向鎖修改狀態位，同時還會有佔用前54位來存儲線程指針作為標示。若該線程再次訪問同一個synchronized方法時，該線程只需去對象頭的Mark Word中去判斷一下是否有偏向鎖指向本身的ID，無需再進入Monitor去競爭對象了。![image.png](./assets/1709140504865-image.png)
